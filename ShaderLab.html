<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>learning webgl</title>
    <script src="lib/structs.js"></script>
</head>
<body style="margin: 0" onload="init(); main()">
<div>
    <canvas id="WebGL" style="width: 100%; height: 300px"></canvas>
</div>
<div>
    <label>
        <textarea rows="20" style="width: 45%" id="vertexShaderCode"
                  onchange="updateShaderCode('vertexShaderCode')"></textarea>
    </label>
    <label>
        <textarea rows="20" style="width: 45%" id="fragmentShaderCode"
                  onchange="updateShaderCode('fragmentShaderCode')"></textarea>
    </label>
</div>
<script>
    const canvas = document.querySelector("#WebGL")
    const gl = canvas.getContext('webgl')

    // 初始化脚本内容
    const init = () => {
        const vertexShaderSrc = `attribute vec4 a_Position;
varying vec4 v_Position;

void main() {
    gl_Position = a_Position;
    v_Position = a_Position;
}
`

        const fragmentShaderSrc = `precision mediump float;

varying vec4 v_Position;

void main() {
    gl_FragColor = vec4(v_Position.rgb / 2.0 + 0.5, 1.0);
}
`

        document.querySelector('#vertexShaderCode').value = vertexShaderSrc
        document.querySelector('#fragmentShaderCode').value = fragmentShaderSrc
    }

    const updateShaderCode = (domId) => {
        const isVertex = domId.startsWith('vertex')
        gl.shaderSource(isVertex ? gl.vertexShader : gl.fragmentShader, document.querySelector(`#${domId}`).value)
        gl.compileShader(isVertex ? gl.vertexShader : gl.fragmentShader)
        const shaderInfoLog = gl.getShaderInfoLog(isVertex ? gl.vertexShader : gl.fragmentShader)
        if (shaderInfoLog) {
            console.log(`shaderInfoLog: ${shaderInfoLog}`)
        } else {
            gl.linkProgram(gl.program)
            console.log(`shader code updated!`)
        }
    }

    const main = () => {
        const createProgram = (vertexShaderSrc, fragmentShaderSrc) => {
            // 顶点着色器
            gl.vertexShader = gl.createShader(gl.VERTEX_SHADER)
            gl.shaderSource(gl.vertexShader, vertexShaderSrc)
            gl.compileShader(gl.vertexShader)
            const vertexShaderInfoLog = gl.getShaderInfoLog(gl.vertexShader)
            console.log(`vertexShaderInfoLog: ${vertexShaderInfoLog}`)

            // 片元着色器
            gl.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)
            gl.shaderSource(gl.fragmentShader, fragmentShaderSrc)
            gl.compileShader(gl.fragmentShader)
            const fragmentShaderInfoLog = gl.getShaderInfoLog(gl.fragmentShader)
            console.log(`fragmentShaderInfoLog: ${fragmentShaderInfoLog}`)

            const shaderProgram = gl.createProgram()
            gl.attachShader(shaderProgram, gl.vertexShader)
            gl.attachShader(shaderProgram, gl.fragmentShader)
            gl.linkProgram(shaderProgram)

            return shaderProgram
        }

        const program = createProgram(document.querySelector('#vertexShaderCode').value, document.querySelector('#fragmentShaderCode').value)
        gl.useProgram(program)
        gl.program = program

        // 顶点坐标
        const data = new Float32Array([-1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0])
        const buffer = gl.createBuffer()
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
        gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW)
        const bytesPerElement = data.BYTES_PER_ELEMENT
        const a_Position = gl.getAttribLocation(program, 'a_Position')
        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, bytesPerElement * 3, 0)
        gl.enableVertexAttribArray(a_Position)

        const draw = () => {
            gl.enable(gl.DEPTH_TEST)
            gl.clearColor(0, 0, 0, 1)
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

            // 画图
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4)
        }

        const drawAndRegisterNextFrame = () => {
            draw()
            requestAnimationFrame(drawAndRegisterNextFrame)
        }

        drawAndRegisterNextFrame()
    }
</script>
</body>
</html>
